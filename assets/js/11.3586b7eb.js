(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{221:function(n,e,i){"use strict";i.r(e);var t=i(0),o=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,e=n.$createElement,i=n._self._c||e;return i("div",{staticClass:"content"},[i("h2",{attrs:{id:"ios获取当前屏幕的视图控制器"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#ios获取当前屏幕的视图控制器","aria-hidden":"true"}},[n._v("#")]),n._v(" iOS获取当前屏幕的视图控制器")]),n._v(" "),i("p",[i("code",[n._v("2016-04-11")])]),n._v(" "),i("p",[n._v("在一些子View中经常需要知道当前是跑在哪个ViewController里，经常由于嵌套太深获取承载VC比较麻烦，这里封装一个方法，用来获取当前屏幕的ViewController.")]),n._v(" "),i("div",{staticClass:"language-Objective-C extra-class"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[n._v("    - (UIViewController *)getCurrentVC\n\n    {\n\n        UIViewController *result = nil;\n\n        \n\n        UIWindow * window = [[UIApplication sharedApplication] keyWindow];\n\n        if (window.windowLevel != UIWindowLevelNormal)\n\n        {\n\n            NSArray *windows = [[UIApplication sharedApplication] windows];\n\n            for(UIWindow * tmpWin in windows)\n\n            {\n\n                if (tmpWin.windowLevel == UIWindowLevelNormal)\n\n                {\n\n                    window = tmpWin;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n        \n\n        UIView *frontView = [[window subviews] objectAtIndex:0];\n\n        id nextResponder = [frontView nextResponder];\n\n        \n\n        if ([nextResponder isKindOfClass:[UIViewController class]])\n\n            result = nextResponder;\n\n        else\n\n            result = window.rootViewController;\n\n        \n\n        return result;\n\n    }\n")])])])])}],!1,null,null,null);e.default=o.exports}}]);