## 网络请求相关
`2018-09-10`

### http/https 请求的具体步奏
- 识别URL
- 查找本地hosts文件
- 查询本地DNS服务器
- 查询根DNS服务器
- 根据IP地址访问服务器，建立TCP三次握手
- 如果是https链接:
    - 建立链接后服务器返回自己的证书
    - 浏览器想CA验证证书的合法性，合法就提取证书里的公钥
    - 通过公钥加密一段对称密钥发给服务器
    - 服务器通私钥解密对称密钥，后续通信通过对称密钥加密
- 浏览器向服务器发送http请求命令，请求头/请求体
- 服务器返回 响应头/响应体
- 如果没有设置 keep-alive，浏览器四次挥手关闭 tcp 连接

#### https 特性
- 端口 443，不同于 http 的80
- https保护了你从连接到这个网站开始，到你关闭这个页面为止，你和这个网站之间收发的所有信息，就连url的一部分都被保护了。
    - confidentiality: 你浏览的页面的内容如果被人中途看见，将会是一团乱码。
    - intergrity: 你浏览的页面就是你想浏览的，不会被黑客在中途修改，网站收到的数据包也是你最初发的那个，不会把你的数据给换掉，搞一个大新闻
    - availability: https本身不保证availability,而且别人也能知道你在上这个网站
    - authentication: 你连接的是你连接的网站，而不是什么人在中途伪造了一个网站给你，专业上叫Man In The Middle Attack

### http 内容结构

#### 请求行
- Method Request-URI HTTP-Version 结尾符
- 结尾符一般用\r\n

#### 请求头

##### 通用报头，既可以出现在请求报头，也可以出现在响应报头中
- Date：表示消息产生的日期和时间
- Connection：允许发送指定连接的选项，例如指定连接是连续的，或者指定“close”选项，通知服务器，在响应完成后，关闭连接
- Cache-Control：用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制）

##### 请求报头，通知服务器关于客户端求求的信息

- Host：请求的主机名，允许多个域名同处一个IP地址，即虚拟主机
- User-Agent：发送请求的浏览器类型、操作系统等信息
- Accept：客户端可识别的内容类型列表，用于指定客户端接收那些类型的信息
- Accept-Encoding：客户端可识别的数据编码
- Accept-Language：表示浏览器所支持的语言类型
- Connection：允许客户端和服务器指定与请求/响应连接有关的选项，例如这是为Keep-Alive则表示保持连接。
- Transfer-Encoding：告知接收端为了保证报文的可靠传输，对报文采用了什么编码方式。

##### 响应报头，用于服务器传递自身信息的响应

- Location：用于重定向接受者到一个新的位置，常用在更换域名的时候
- Server：包含可服务器用来处理请求的系统信息，与User-Agent请求报头是相对应的

##### 实体报头，用来定于被传送资源的信息，既可以用于请求也可用于响应，请求和响应消息都可以传送一个实体

- Content-Type：发送给接收者的实体正文的媒体类型
- Content-Lenght：实体正文的长度
- Content-Language：描述资源所用的自然语言，没有设置则该选项则认为实体内容将提供给所有的语言阅读
- Content-Encoding：实体报头被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。
- Last-Modified：实体报头用于指示资源的最后修改日期和时间
- Expires：实体报头给出响应过期的日期和时间

#### 空行

- http协议规定的格式，一般采用\r\n

#### 消息主体

- 通过实体报头规定消息主体的格式内容。例如 `Content-Type=text/plain`报头规定了消息主体的数据是纯文本格式
- Content-Type=application/x-www-form-urlencoded，定义为Key=value格式
- Content-Type=application/json，定义为序列化为的json字符串
- Content-Type= multipart/form-data，定义为表单数据提交

### http1.x 与 http2

#### http2 新特性

- 帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。
- 流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。
- HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。二进制更加高效。
- 同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装

#### 多路复用

- 多路复用，代替原来的序列和阻塞机制。所有就是请求的都是通过一个 TCP连接并发完成。
- 在 http1.x 发送请求虽然可以并发发起，但是服务器端的响应的发送要根据请求被接收的顺序排队。这个现象称为：队首阻塞
- http2无论在客户端还是在服务器端都不需要排队，在同一个tcp连接上，有多个stream，由各个stream发送和接收http请求，各个steam相互独立，互不阻塞。

#### 服务器推送

- 服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。
- 服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。

#### 头部压缩

- HTTP/2对消息头采用HPACK（专为http/2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量。
- HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；
- 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;
- 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。

### 常见 http 状态码

#### 1XX系: 表示临时响应并需要请求者继续执行操作的状态代码。

| 状态码 | 类型 | 意义 |
| :------| :------ | :------ |
| 100 | 继续 | 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分 |
| 101 | 切换协议 | 请求者已要求服务器切换协议，服务器已确认并准备切换 |

#### 2XX：请求已成功被服务器接收、理解、并接受

| 状态码 | 类型 | 意义 |
| :------| :------ | :------ |
| 200 | 成功 | 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页 |
| 201 | 已创建 | 请求成功并且服务器创建了新的资源 |
| 202 | 已接受 | 服务器已接受请求，但尚未处理 |
| 203 | 非授权信息 | 服务器已成功处理了请求，但返回的信息可能来自另一来源 |
| 204 | 无内容 | 服务器成功处理了请求，但没有返回任何内容。比如 DETELE 请求 |
| 205 | 重置内容 | 服务器成功处理了请求，但没有返回任何内容 |
| 206 | 部分内容 | 服务器成功处理了部分 GET 请求 |

#### 3XX：需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的 Location 域中指明

| 状态码 | 类型 | 意义 |
| :------| :------ | :------ |
| 300 | 多种选择 | 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择 |
| 301 | 永久移动 | 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置 |
| 302 | 临时移动 | 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求 |
| 303 | 查看其他位置 | 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码 |
| 304 | 未修改 | 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容 |
| 305 | 使用代理 | 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理 |
| 307 | 临时重定向 | 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求 |

#### 4XX：请求错误

| 状态码 | 类型 | 意义 |
| :------| :------ | :------ |
| 400 | 错误请求 | 服务器不理解请求的语法 |
| 401 | 未授权 | 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应 |
| 403 | 禁止 | 服务器拒绝请求 |
| 404 | 未找到 | 服务器找不到请求的网页 |
| 405 | 方法禁用 | 禁用请求中指定的方法 |
| 406 | 不接受 | 无法使用请求的内容特性响应请求的网页 |
| 407 | 需要代理授权 | 此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理 |
| 408 | 请求超时 | 服务器等候请求时发生超时 |
| 409 | 冲突 | 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息 |
| 410 | 已删除 | 如果请求的资源已永久删除，服务器就会返回此响应 |
| 411 | 需要有效长度 | 服务器不接受不含有效内容长度标头字段的请求 |
| 412 | 未满足前提条件 | 服务器未满足请求者在请求中设置的其中一个前提条件 |
| 413 | 请求实体过大 | 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力 |
| 414 | 请求的 URI 过长 | 请求的 URI(通常为网址)过长，服务器无法处理 |
| 415 | 不支持的媒体类型 | 请求的格式不受请求页面的支持 |
| 416 | 请求范围不符合要求 | 如果页面无法提供请求的范围，则服务器会返回此状态代码 |
| 417 | 未满足期望值 | 服务器未满足"期望"请求标头字段的要求 |

#### 5XX：服务器错误

| 状态码 | 类型 | 意义 |
| :------| :------ | :------ |
| 500 | 服务器内部错误 | 服务器遇到错误，无法完成请求 |
| 501 | 尚未实施 | 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码 |
| 502 | 错误网关 | 服务器作为网关或代理，从上游服务器收到无效响应 |
| 503 | 服务不可用 | 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态 |
| 504 | 网关超时 | 服务器作为网关或代理，但是没有及时从上游服务器收到请求 |
| 505 | HTTP 版本不受支持 | 服务器不支持请求中所用的 HTTP 协议版本 |

### 常见 restful 方法

#### GET

- GET会方法请求指定的页面信息，并返回响应主体
- 用于不会产生副作用的非幂等的操作
- GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。

#### HEAD

- HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。
- 但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。通常用来查看服务器的性能。

#### OPTION

- OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。
- 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用'*'来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。XMLHttpRequest对象进行CORS跨域资源共享时，浏览器就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。

#### DELETE

- DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，返回 204 No Content
- DELETE 方法也是幂等操作

#### POST

- POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。
- POST方法是非幂等的方法，因为这个请求可能会创建新的资源

#### PUT

- PUT请求会身向指定资源位置上传其最新内容，法客户端可以将指定资源的最新数据传送给服务器修改指定的资源的内容。
- PUT 方法是幂等操作

#### CONNECT

- CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。

#### TRACE

- TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。

#### PATCH

- PATCH与PUT不同，PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。
- 当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。

### 其他

#### http 缓存: Expires / Cache-control, Etag 和 Last-Modified 的关系

- Last-Modified不能解决的下列问题：
    - 1、周期性更改的文件且内容并不改变(仅仅改变的修改时间)。
    - 2、有些文件修改极其频繁，也许1秒内修改了很多次，If-Modified-Since能检查到的最小单位是秒级的，所以这种修改无法判断
    - 3、不能精确得到文件的最后修改时间
- 所以Etag是为了弥补Last-Modified的不足，Request-headers的If-None-Match与Response-headers的ETag就返回304，不用返回整个文档

| 状态 | 含义 |
| :------| :------ |
| 200状态 | 当浏览器本地没有缓存或者下一层失效时，或者用户点了强制刷新时，浏览器直接去服务器下载最新的数据 |
| 304状态 | 这一层由 Last-Modified 和 Etag 控制，当下一层失效时或者用户点了强制刷新时，浏览器就会发送请求给服务器，如果服务器端没有变化，则返回304给浏览器|
| [attribute~=value] |  这一层由 Expires 和 Cache-control 控制。1、Expires(http1.0有效)是绝对时间；2、Cache-control(http1.1有效)是相对时间；两者同时存在时，Cache-control覆盖Expires，只要没有失效，浏览器只访问自己的缓存 |